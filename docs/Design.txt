About this document
===================

This document explains the initial set of use cases and design thinking that influenced the way in which Dexterity is built. We will try to keep it relevant and up to date, but you should look at interface documentation and other documentation in the actual packages for details about how Dexterity works and how to work with it.

About Dexterity
===============

Dexterity is the code name for a new way of creating and managing content types in Plone. It aims to take the power to create content types out of the realm of developers and put it in the hands of site administrators and business analysts. Dexterity is also designed to work well with GUI tools ala Gensis or ArchGenXML.

Dexterity does not explicitly aim to integrate with Archetypes - at least not at this stage. The intention is for the two to co-exist peacefully. Hopefully, Archetypes will be refactored to use many of the same technologies as Dexterity, such as plone.app.relations, zope.app.form widgets and so on, so that the choice between the two is largely an implementation detail.

User story - creating content types
-----------------------------------

Plone gains a new control panel called "Content types and forms". Through this control panel, a non-developer can choose to create a new type. She will enter basic type properties, such as a title, whether the type is folderish and so on. She also selects any number of behaviours she wants to enable enable, such as locking, versioning, local role security, the ability to assign portlets, or title-to-id renaming.

She then enters into a schema editor. Here, she can add any number of fields to build a data model of the new type. Naturally, fields can be edited, deleted or re-ordered as necessary.

When the type definition is saved, presuming the type has been enabled, it will show up through the Plone interface, just as a normal content type.

User story - packaging up a content type to deploy elsewhere
------------------------------------------------------------

So far, the type has lived in the ZODB only. All the settings made through the web can, however, be exported and re-imported using GenericSetup.

User story - adding new behaviour to content types
--------------------------------------------------

Some behaviour cannot be managed entirely through-the-web. In this case, we need a unique type interface for the type. In Zope 3 parlour, this is the "IContentType" interface. That is, if you call queryContentType() on a Dexterity-managed object, you should get back a type-specific interface, which itself will be marked with IContentType.

Having a unique interface makes it possible to register adapters, say, or perform runtime introspection on this type. Thus, a business analyst can defer some advanced tasks to a programmer by having the programmer work on a filesystem package with access to the full power of Python.

A programmer can run a 'paster' command to create a new package housing a content type. Before paster generates the skeleton, he is asked for the URL to a web service that describes the type as created through the web (this requires a running site and must be subject to security). The web service gives paster enough information to generate a package that is equivalent to has been managed TTW. The schema and type properties are held in an XML file and loaded dynamically as necessary.

If the package is installed in the Plone site where the type was originally defined, the installer will reconcile the two type definitions. If both have changed in incompatible ways, the user will be asked to choose whether to override the TTW version or the filesystem version. Once the two have been connected, they are one and the same.

Future modifications to the schema TTW will edit the model on the filesystem. When edited TTW, the model will be automatically snapshot so that it's possible to undo any unintended changes.

User story - creating content types with alternative tools
----------------------------------------------------------

A visual, standalone tool such as ArchGenXML/Genesis can be used to manage the XML model created paster as above. In this case, the schema did not originate TTW, but the same XML format and API are used.

User story - creating views
---------------------------

When a new type is defined TTW, it will per default have basic "view" and "edit" tabs. In the GUI, the user can choose to generate a template for the view taking place of the generic one. Rather than being a generic template, this is a flat ZPT that prints all field values in a simple layout. The user can then change this through the web as appropriate, using the portal_view_customizations GUI in the same way that other views can be customised.

If and when the type is moved to the filesystem, it will be registered as a normal view. If desired, this can be overridden TTW using portal_view_customizations.

 NOTE: We likely want some better sync-with-filesystem support for portal_view_customizations, but that's beyond the scope of Dexterity.

User story - creating forms
---------------------------

 NOTE: Form support will be a secondary concern until the basic content type framework is in place. The forms use case will not be considered in further detail for now.

The Dexterity system also allows the creation of standalone forms. Forms use the same schema representation and GUI, but do not result in a content type.

Forms are added to the Plone content hierarchy with a generic 'Form' content type. When instantiated, this type allows the user to choose from any available forms. When a form is validated and saved, it can be associated with a pre-defined content rule. A set of actions like "send as email" or "save to relational database" are available for rules that can act as form actions.

Form packages can be exported or re-created with web services as with content types. The XML representation of a form shares applicable elements with that of a content type.

======================
Resulting requirements
======================

 - A GUI for creating new types
 - A custom FTI type for storing type properties and the persistent representation of a schema configuration
 - A way to maintain unique interfaces for TTW-created types
 - Add and edit forms that are based on a Dexterity-supplied schema
 - A registry of selectable "behaviours" (applied by marker interface)
 - A mechanism to discover and compose a schema that includes the core schema and any fields provided by additional behaviours
 - A factory to turn a prototype Dexterity content object into a type-specific one
 - The ability to define and control "add" permissions
 - Dynamic field-level security
 - The ability to move a type from TTW-defined to filesystem (this involves "connecting" to a filesystem schema and performing any necessary migration of existing content)
 - Schema/type snapshot (versioning)
 - A web service to introspect/export type information and TTW schema
 - Ability to lock a package-based type to disable future TTW modification
 - Ability to copy-and-extend ("customise") the type definition TTW if it's "locked

===============
Implementation
===============

Please refer to the Dexterity.graffle/Dexterity.png diagram.

Through-the-web
---------------

New content can be created through-the-web. In this case, we get the following:

 - A new FTI object of type "Dexterity FTI" is installed in portal_types for each custom type. This holds basic type properties and acts as a container for other type-specific persistent information.
 
 - The FTI can return a type-specific IContentType schema interface. Whilst the type lives TTW, this is generated dynamically from a persisted abstraction of the schema. (When the type moves to the filesystem, there will be a real interface - see below). This dynamic interface can change if the schema is edited TTW. The interface will be generated in a dynamic module that creates it on the fly (via a __getattr__ hook) by looking up information in the FTI. This ensures that it is always available and guards against unpickling errors.
 
 - A local, named utility is registered as the factory for the new type.
 
 - The factory will create objects that derive from "Dexterity Content" or "Dexterity Folder", as appropriate. This provides all necessary Zope, CMF and Plone integration. The factory also ensures that the appropriate IContentType interface is provided by the instance.
 
 - The factory sets the correct portal_type as an instance variable.
 
 - The factory initialises security (read/write permissions on fields in the schema) on the object.
 
 - A general view, "@@view" is registered for any IDexterityType. By default, this simply renders the values of all fields. However, the standard view can be customised. Under the hood, this uses portal_view_customizations to create a custom view for the type-specific interface. When the customised copy is created, it will be populated with some generated ZPT code that renders each field explicitly and include the other Plone boilerplate (viewlet manager invocations etc). Whilst this will not automatically accommodate new fields, it makes it much easier to create a custom view by adding static HTML and moving things around.
 
 - A general view "@@edit" is registered for any IDexterityContent. This uses formlib to set up a view based on the defined schema in combination with any schemata provided by additional behaviour-identifying marker interfaces. The full schema held in the FTI may include hints about widgets and other view-specific information as well, such as fields to omit.
 
Filesystem
----------
 
Content can also be represented on the filesystem:

 - A "Dexterity FTI" is installed, but is configured to read the schema from disk. Other type properties are managed with GenericSetup as normal.
 
 - The schema and associated declarative metadata (such as widget hints) is held in an XML file locally.
 
 - A proper filesystem interface is loaded from this schema, for example:
 
    class IMyType( XMLSchema('mytype.xml') ):
         """My custom type
         """

   The point here is that we have a real interface, for which adapters and event handlers can be registered, with real zope.schema fields that are loaded from the XML file. It's possible to do other things with Python code in the interface body, of course. The (dynamic) base interface ensures that IMyType is marked with IContentType as well, so that queryContentType() will return it.

 - The schema is still available from the FTI, but is loaded from an XML representation.
 
 - If it is not declared as locked, the schema can be edited using the same TTW GUI. Changes will be saved to the filesystem XML file, but there will be snapshots to ensure unintended changes can be rolled back.
 
 - A general factory utility takes care of creating the "Dexterity Content" or "Dexterity Folder" object, applying behaviours and setting the portal_type as above. It applies the custom schema interface to the created object, and initialises the attributes from the schema on the created instance.

 - A standard @@view view will still apply, but a custom view is likely to have been registered for the type-specific interface. This works like any other view.
 
 - If the developer wishes to customise the storage of the schema attributes or needs to provide other overrides, he can provide a new content class. This will subclass DexterityContent/DexterityFolder (the generic content classes). In this case, a new factory utility needs to be registered, so that the correct class is used during type construction. Dexterity should provide a utility factory (a specialisation of zope.component.factory.Factory) for this purpose.
 
  Note: Ideally, no-one should need to provide their own class. Additional behaviour is better modelled using adapters.

Migration
---------

Existing TTW content can be migrated to filesystem content types and vice-a-versa when the link between a filesystem package and a TTW schema is created or broken (for schema customisation). In this case:

 - The "filesystem link" aspect of the FTI is enabled or disabled, as appropriate.
 
 - The schema is connected to or disconnected from its filesystem representation (XML) as appropriate.

 - A catalogue search finds all content types of the given portal_type and exchanges the dynamic IContentType interface with the type-specific interfaces. If required, it may also change the portal_type and even the __class__ (in cases where the developer has had to subclass the default types).
 
 - Local named template adapters and factory utilities may be removed or created as necessary, and ZPT contents for named template adapters may be copied to or from the filesystem as appropriate.
 
To be considered in more detail
-------------------------------

 - How to do per-type add permissions?
    
    -> most likely, this will be achieved by creating a custom permission and checking it explicitly in the FTI and/or factory.

